Tureasy is a general purpose programming language designed by team IITH3 in 2020 as p part of POPL-1 project. The language got its name from two words `Turing` and `Easy`. The word `Turing` is given in honour to Alan Turing, the founder of the famous imitation game (Turing Test). The word `Easy` is given to signify the ease of programming in this language.

Tureasy evolved over the last one month. The basic idea which motivated the language design in the beginning was even dumbest programmers should be able to improve writing code in our language. This made us come up with an idea called smart compiler which is more than a mere translator. There are many other languages that provide certain improvements in code internally, but the programmer seldom has a role to play in it. In Tureasy language, a concept called `tags` was introduced that was improved over time. These tags analyse the code between them at the abstract syntax tree level of compilation and provide user with appropriate suggestions. We realized that only tags aren't sufficient for analysis and we came up with an idea of turzers. These turzers are similar to packages in Java, but they store data models. These models will be specific to the tag names. Later, we felt the need for training data for these turzers so we planned on creating a server and an IDE for Tureasy language that would collect data from the user (with his consent) and improve its models over years. We planned to extend tags for companies and industries, so we introduced private tags and turzers. These tags are designed based on the company's requirement and the turzers are made private to ensure that the data is secure and confidential.

Tureasy evolved even further in view of tags. In the early stages of design we planned to give `tips` to the programmer about the improvements. Later we realized that there is a need to address other issues like memory optimization, parallelized implementations, time complexity analysis and possible runtime errors and logical errors. These aspects are usually left to the programmer to figure out. In companies, programmers might develop projects in a much better way if compiler supported them. In achieving these goals, we tried to come up with tags addressing specific issues. The optimization can be done by analyzing the data usage in the program and this can be done by using certain tags which keep track of the data usages in program. There are certain parallelized algorithms which are currently being added to other programming languages too. We realized that the major issue is for the programmer to make sure that he uses the hardware efficiently. So, we planned to provide turzers access to the hardware and it could come up with possible parallelized alternatives. One of the major evolution in domain of time complexity can be attributed to the `GLORE` algorithms which was developed by Japan. We planned to address the most common problems faced in competitive programming, runtime and logical errors. Tureasy was made to analyze the possible scenarios for the code to fail during runtime (appropriate tags need to be used). Our research about logical errors made us realize that a rigorous proof could eliminate them. So, tureasy was designed to make sure that the tags are used for providing constraints or conditions that could be used for internally for proving the correctness. The inspiration for the logical errors' analysis came from `Prolog` language which uses rules and facts to come up with answers for the queries. Similar logic is used by turzers for sake of finding fault.

As we developed the language we felt the need for programmer to get sample code for understanding the tips even better. This is not possible in all scenarios but could be done in most of them. The inspiration for this came from the concept of meta programming in `Lisp`. We are still working on including this in Tureasy.
Tureasy also evolved in other aspects of programming language. The variables and operators are similar to Java. The conditional and iterative statements have their own unique syntax and we tried to avoid curly braces (like C) or indentation for blocks (like Python). We got inspired by the `Ruby` language end statement which marks the end of block and thus used special operators to end the block. As we already mentioned in the slides, we focused on symbolic coding in our syntax.  Tureasy made sure that the distinction between user defined functions and in-built functions is less, that is, the user is provided with lot of scope to develop based on her requirements. As we designed, we tried to provide local functions which could be defined within other functions. The inspiration came from `R` language. But we made sure that recursion is not provided to these local functions (as of now). The strings library of Tureasy provides some unique functions which makes programmer's life easier. 

Even though Tureasy is a general purpose language, we tried to focus on addressing project requirements of companies. OOPS is included in tureasy for the same. In the early stages of language only concepts of classes and data encapsulation was designed. Later, other concepts of overloading and inheritance were also designed. We are still working on the scope resolution operator related uses. In recent days generic types were added to Tureasy for programmer's ease of coding. These generic types began with lists and now include stacks, dictionaries, bitsets etc.

Low level details are also meticulously included in Tureasy. Certain concepts like variable shadowing and obscuring, scope and linkage are analysed carefully developed as Tureasy evolved. We are planning to develop the language design by focusing on specific domains in the future.

